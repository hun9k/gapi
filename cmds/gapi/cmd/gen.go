package cmd

import (
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/iancoleman/strcase"
)

func genHandlers(doc *openapi3.T, out string) error {
	if doc == nil || doc.Paths == nil {
		return nil
	}

	// 获取输出目录作为包名
	dir := filepath.Dir(out)
	pkgName := filepath.Base(dir)
	if pkgName == "." || pkgName == "/" {
		pkgName = "routers"
	}

	// 创建文件
	f := jen.NewFile(pkgName)

	// 添加文件头注释
	f.HeaderComment("Code generated by gapi. DO NOT EDIT.")
	f.Line()

	// 生成路由注册函数
	f.Comment("RegisterRoutes registers all API routes")
	f.Func().Id("RegisterRoutes").Params().BlockFunc(func(g *jen.Group) {
		// 处理服务器配置中的路径前缀
		if len(doc.Servers) > 0 {
			for _, server := range doc.Servers {
				if server == nil || server.URL == "" {
					continue
				}
				// 解析服务器URL获取路径前缀
				u, err := url.Parse(server.URL)
				if err != nil {
					continue
				}
				// 规范化路径，确保不以/结尾
				u.Path = strings.TrimSuffix(u.Path, "/")
				if u.Path != "" && u.Path != "/" {
					// 创建路由组变量名
					pathParts := strings.Split(strings.Trim(u.Path, "/"), "/")
					groupName := "g"
					for _, part := range pathParts {
						if part != "" {
							groupName += strcase.ToCamel(part)
						}
					}

					// 创建路由组
					g.Comment(fmt.Sprintf("Create route group for %s", u.Path))
					g.Id(groupName).Op(":=").Qual("github.com/hun9k/gapi", "Handler").Call(jen.Lit(u.Path))

					// 为每个路径注册路由
					for path, pathItem := range doc.Paths.Map() {
						if pathItem == nil {
							continue
						}

						// 处理每个 HTTP 方法
						operations := map[string]*openapi3.Operation{
							"GET":     pathItem.Get,
							"POST":    pathItem.Post,
							"PUT":     pathItem.Put,
							"DELETE":  pathItem.Delete,
							"PATCH":   pathItem.Patch,
							"HEAD":    pathItem.Head,
							"OPTIONS": pathItem.Options,
						}

						for method, operation := range operations {
							if operation == nil {
								continue
							}

							// 生成 handler 函数名
							handlerName := generateHandlerName(operation, path, method)

							// 生成路由注册代码
							g.Comment(fmt.Sprintf("Register %s %s", method, path))
							g.Id(groupName).Dot(strings.ToUpper(method)).Call(
								jen.Lit(path),
								jen.Id(handlerName),
							)
						}
					}
				}
			}
		} else {
			// 没有服务器配置时，直接注册路由
			g.Id("g").Op(":=").Qual("github.com/hun9k/gapi", "Handler").Call()

			// 为每个路径注册路由
			for path, pathItem := range doc.Paths.Map() {
				if pathItem == nil {
					continue
				}

				// 处理每个 HTTP 方法
				operations := map[string]*openapi3.Operation{
					"GET":     pathItem.Get,
					"POST":    pathItem.Post,
					"PUT":     pathItem.Put,
					"DELETE":  pathItem.Delete,
					"PATCH":   pathItem.Patch,
					"HEAD":    pathItem.Head,
					"OPTIONS": pathItem.Options,
				}

				for method, operation := range operations {
					if operation == nil {
						continue
					}

					// 生成 handler 函数名
					handlerName := generateHandlerName(operation, path, method)

					// 生成路由注册代码
					g.Comment(fmt.Sprintf("Register %s %s", method, path))
					g.Id("g").Dot(strings.ToUpper(method)).Call(
						jen.Lit(path),
						jen.Id(handlerName),
					)
				}
			}
		}
	})
	f.Line()

	// 生成所有handler函数
	for path, pathItem := range doc.Paths.Map() {
		if pathItem == nil {
			continue
		}

		// 处理每个 HTTP 方法
		operations := map[string]*openapi3.Operation{
			"GET":     pathItem.Get,
			"POST":    pathItem.Post,
			"PUT":     pathItem.Put,
			"DELETE":  pathItem.Delete,
			"PATCH":   pathItem.Patch,
			"HEAD":    pathItem.Head,
			"OPTIONS": pathItem.Options,
		}

		for method, operation := range operations {
			if operation == nil {
				continue
			}

			// 生成 handler 函数名
			handlerName := generateHandlerName(operation, path, method)

			// 添加函数注释
			comment := fmt.Sprintf("%s handles %s %s", handlerName, method, path)
			if operation.Summary != "" {
				comment += "\n// " + operation.Summary
			}
			f.Comment(comment)

			// 生成 handler 函数结构
			f.Func().Id(handlerName).Params(
				jen.Id("c").Op("*").Qual("github.com/gin-gonic/gin", "Context"),
			).Block(
				jen.Comment("TODO: implement handler logic"),
			)
			f.Line()
		}
	}

	// 添加init函数
	f.Func().Id("init").Params().Block(
		jen.Id("RegisterRoutes").Call(),
	)

	// 确保输出目录存在
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// 保存到目标文件
	return f.Save(out)
}

// generateHandlerName 生成处理器函数名，格式如：PutUserUsername
// generateHandlerName 生成处理器函数名，格式如：PostUserCreateWithList
func generateHandlerName(operation *openapi3.Operation, path, method string) string {
	// 优先使用OperationId
	if operation != nil && operation.OperationID != "" {
		return strcase.ToCamel(operation.OperationID)
	}

	// 从路径生成函数名
	pathParts := strings.Split(strings.Trim(path, "/"), "/")
	if len(pathParts) == 0 || (len(pathParts) == 1 && pathParts[0] == "") {
		pathParts = []string{"default"}
	}

	// 清理路径部分，移除特殊字符
	for i, part := range pathParts {
		// 移除路径参数标记
		part = strings.Trim(part, "{}")
		// 转换为驼峰命名
		part = strcase.ToCamel(part)
		pathParts[i] = part
	}

	// 生成函数名：方法名 + 路径部分
	methodName := strcase.ToCamel(strings.ToLower(method))
	pathName := strings.Join(pathParts, "")
	return fmt.Sprintf("%s%s", methodName, pathName)
}

func genPathMessages(doc *openapi3.T, path, outputDir string) error {
	if doc.Paths == nil {
		return nil
	}

	// 获取路径项
	pathItem := doc.Paths.Value(path)
	if pathItem == nil {
		return fmt.Errorf("path %s not found in openapi spec", path)
	}

	// 确保输出目录存在
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// 使用输出目录的最后部分作为包名，默认为 messages
	pkgName := filepath.Base(filepath.Clean(outputDir))
	if pkgName == "." || pkgName == "/" || !isValidGoIdentifier(pkgName) {
		pkgName = "messages"
	}
	// 确保包名是有效的 Go 标识符
	pkgName = sanitizePackageName(pkgName)

	// 使用 filepath.Base 获取文件名
	baseName := filepath.Base(path)
	// 如果是根路径，使用 default
	if baseName == "." || baseName == "/" {
		baseName = "default"
	}
	// 确保文件名是有效的 Go 标识符
	fileName := strcase.ToSnake(baseName)
	if !isValidGoIdentifier(fileName) {
		fileName = "default"
	}
	fileName = filepath.Join(outputDir, fmt.Sprintf("%s_gen.go", fileName))

	// 创建文件
	f := jen.NewFile(pkgName)

	// 在文件开头添加注释
	f.HeaderComment("Code generated by gapi. DO NOT EDIT.")

	// 处理每个 HTTP 方法
	operations := map[string]*openapi3.Operation{
		"GET":     pathItem.Get,
		"POST":    pathItem.Post,
		"PUT":     pathItem.Put,
		"DELETE":  pathItem.Delete,
		"PATCH":   pathItem.Patch,
		"HEAD":    pathItem.Head,
		"OPTIONS": pathItem.Options,
	}

	// 将路径转换为大驼峰形式，并限制长度
	pathCamel := strcase.ToCamel(strings.ReplaceAll(strings.Trim(path, "/"), "/", "_"))
	if len(pathCamel) > 50 {
		pathCamel = pathCamel[:50]
	}

	for method, operation := range operations {
		if operation == nil || operation.OperationID == "" {
			continue
		}

		// 生成请求类型
		if operation.RequestBody != nil && operation.RequestBody.Value != nil {
			for contentType, mediaType := range operation.RequestBody.Value.Content {
				if mediaType == nil || mediaType.Schema == nil || contentType == "" {
					continue
				}

				// 从内容类型中提取类型名
				contentTypeParts := strings.Split(contentType, "/")
				if len(contentTypeParts) == 0 {
					continue
				}
				contentTypeName := strcase.ToCamel(contentTypeParts[len(contentTypeParts)-1])

				// 生成请求类型名：路径+方法+Request+内容类型
				typeName := fmt.Sprintf("%s%sRequest%s",
					pathCamel,
					strcase.ToCamel(method),
					contentTypeName)

				// 确保类型名有效
				if !isValidGoIdentifier(typeName) {
					continue
				}

				f.Comment(fmt.Sprintf("%s represents the request body for %s %s (content-type: %s)", typeName, method, path, contentType))
				f.Type().Id(typeName).StructFunc(func(g *jen.Group) {
					if mediaType.Schema.Ref != "" {
						// 如果是引用类型，直接嵌入
						refParts := strings.Split(mediaType.Schema.Ref, "/")
						if len(refParts) == 0 {
							return
						}
						refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
						g.Id(refTypeName)
					} else {
						// 生成内联结构体
						if err := generateStructFields(g, mediaType.Schema); err != nil {
							return
						}
					}
				})
				f.Line()
			}
		}

		// 生成响应类型
		if operation.Responses == nil {
			continue
		}
		for statusCode, response := range operation.Responses.Map() {
			if response == nil || response.Value == nil {
				continue
			}

			for contentType, mediaType := range response.Value.Content {
				if mediaType == nil || mediaType.Schema == nil || contentType == "" {
					continue
				}

				// 从内容类型中提取类型名
				contentTypeParts := strings.Split(contentType, "/")
				if len(contentTypeParts) == 0 {
					continue
				}
				contentTypeName := strcase.ToCamel(contentTypeParts[len(contentTypeParts)-1])

				// 处理状态码，确保是有效的类型名部分
				statusCodeName := statusCode
				if strings.HasPrefix(statusCode, "2") || strings.HasPrefix(statusCode, "3") ||
					strings.HasPrefix(statusCode, "4") || strings.HasPrefix(statusCode, "5") {
					statusCodeName = "Status" + statusCode
				} else {
					statusCodeName = strcase.ToCamel(statusCode)
				}

				// 生成响应类型名：路径+方法+状态码+Response+内容类型
				typeName := fmt.Sprintf("%s%s%sResponse%s",
					pathCamel,
					strcase.ToCamel(method),
					statusCodeName,
					contentTypeName)

				// 确保类型名有效
				if !isValidGoIdentifier(typeName) {
					continue
				}

				f.Comment(fmt.Sprintf("%s represents the response body for %s %s (status: %s, content-type: %s)", typeName, method, path, statusCode, contentType))
				f.Type().Id(typeName).StructFunc(func(g *jen.Group) {
					if mediaType.Schema.Ref != "" {
						// 如果是引用类型，直接嵌入
						refParts := strings.Split(mediaType.Schema.Ref, "/")
						if len(refParts) == 0 {
							return
						}
						refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
						g.Id(refTypeName)
					} else {
						// 生成内联结构体
						if err := generateStructFields(g, mediaType.Schema); err != nil {
							return
						}
					}
				})
				f.Line()
			}
		}
	}

	// 直接保存到目标文件
	if err := f.Save(fileName); err != nil {
		return fmt.Errorf("failed to save generated file: %w", err)
	}
	return nil
}

// isValidGoIdentifier 检查字符串是否是有效的 Go 标识符
func isValidGoIdentifier(s string) bool {
	if s == "" {
		return false
	}
	for i, r := range s {
		if unicode.IsLetter(r) {
			continue
		}
		if i > 0 && unicode.IsDigit(r) {
			continue
		}
		if r == '_' {
			continue
		}
		return false
	}
	return true
}

// sanitizePackageName 确保包名是有效的 Go 标识符
func sanitizePackageName(name string) string {
	// 移除所有非字母数字字符
	reg := regexp.MustCompile(`[^a-zA-Z0-9_]`)
	name = reg.ReplaceAllString(name, "_")

	// 确保以字母开头
	if len(name) > 0 && !unicode.IsLetter(rune(name[0])) {
		name = "pkg_" + name
	}

	// 如果为空，使用默认值
	if name == "" || name == "_" {
		name = "messages"
	}

	return name
}

// generateStructFields 生成结构体字段
func generateStructFields(g *jen.Group, schemaRef *openapi3.SchemaRef) error {
	if schemaRef == nil {
		return nil
	}

	schema := schemaRef.Value

	for propName, propRef := range schema.Properties {
		if propRef == nil || propRef.Value == nil {
			continue
		}

		fieldName := strcase.ToCamel(propName)

		// 处理引用类型
		if propRef.Ref != "" {
			refParts := strings.Split(propRef.Ref, "/")
			refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
			if propRef.Value.Nullable {
				g.Id(fieldName).Op("*").Id(refTypeName).Tag(map[string]string{"json": propName + ",omitempty"})
			} else {
				g.Id(fieldName).Id(refTypeName).Tag(map[string]string{"json": propName})
			}
			continue
		}

		// 处理数组类型
		if propRef.Value.Type.Is("array") && propRef.Value.Items != nil {
			if propRef.Value.Items.Ref != "" {
				refParts := strings.Split(propRef.Value.Items.Ref, "/")
				refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
				if propRef.Value.Nullable {
					g.Id(fieldName).Op("[]*").Id(refTypeName).Tag(map[string]string{"json": propName + ",omitempty"})
				} else {
					g.Id(fieldName).Op("[]").Id(refTypeName).Tag(map[string]string{"json": propName + ",omitempty"})
				}
			} else {
				itemType := getGoType(propRef.Value.Items)
				if propRef.Value.Nullable {
					g.Id(fieldName).Op("[]*").Add(itemType).Tag(map[string]string{"json": propName + ",omitempty"})
				} else {
					g.Id(fieldName).Op("[]").Add(itemType).Tag(map[string]string{"json": propName + ",omitempty"})
				}
			}
			continue
		}

		// 处理对象类型
		if propRef.Value.Type.Is("object") {
			if len(propRef.Value.Properties) > 0 {
				// 创建内联结构体
				g.Id(fieldName).StructFunc(func(innerG *jen.Group) {
					if err := generateStructFields(innerG, propRef); err != nil {
						return
					}
				})
				if propRef.Value.Nullable {
					g.Op("*")
				}
				g.Tag(map[string]string{"json": propName + ",omitempty"})
			}
			continue
		}

		// 处理基本类型
		fieldType := getGoType(propRef)
		tags := map[string]string{"json": propName}
		if propRef.Value.Nullable {
			tags["json"] += ",omitempty"
			fieldType = jen.Op("*").Add(fieldType)
		}
		g.Id(fieldName).Add(fieldType).Tag(tags)
	}

	return nil
}
func genSchemas(doc *openapi3.T, out string) error {
	if doc == nil || doc.Components == nil || doc.Components.Schemas == nil {
		return nil
	}

	// 获取输出目录作为包名
	dir := filepath.Dir(out)
	pkgName := filepath.Base(dir)
	if pkgName == "." || pkgName == "/" {
		pkgName = "messages"
	}

	// 创建单个文件
	f := jen.NewFile(pkgName)

	// 添加文件头注释
	f.HeaderComment("Code generated by gapi. DO NOT EDIT.")
	f.Line()

	// 为每个 schema 生成结构体
	for name, schemaRef := range doc.Components.Schemas {
		if schemaRef == nil || schemaRef.Value == nil {
			continue
		}

		// 创建结构体
		f.Comment(fmt.Sprintf("%s represents the %s model", strcase.ToCamel(name), name))
		f.Type().Id(strcase.ToCamel(name)).StructFunc(func(g *jen.Group) {
			schema := schemaRef.Value

			// 处理所有属性
			for propName, propRef := range schema.Properties {
				if propRef == nil || propRef.Value == nil {
					continue
				}

				// 处理字段名
				fieldName := strcase.ToCamel(propName)

				// 创建标签，使用蛇形命名
				tags := map[string]string{
					"json": strcase.ToSnake(propName),
					"form": strcase.ToSnake(propName),
					"xml":  strcase.ToSnake(propName),
				}

				// 检查是否是引用类型（嵌入）
				if propRef.Ref != "" {
					refParts := strings.Split(propRef.Ref, "/")
					refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
					// 如果是 nullable，使用指针类型
					if propRef.Value != nil && propRef.Value.Nullable {
						g.Id(fieldName).Op("*").Id(refTypeName).Tag(tags)
					} else {
						g.Id(fieldName).Id(refTypeName).Tag(tags)
					}
					continue
				}

				// 处理数组类型的引用
				if propRef.Value.Type.Is("array") && propRef.Value.Items != nil {
					if propRef.Value.Items.Ref != "" {
						refParts := strings.Split(propRef.Value.Items.Ref, "/")
						refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
						// 如果是 nullable，使用指针类型的切片
						if propRef.Value.Nullable {
							g.Id(fieldName).Op("[]*").Id(refTypeName).Tag(tags)
						} else {
							g.Id(fieldName).Op("[]").Id(refTypeName).Tag(tags)
						}
						continue
					}
					// 处理普通数组类型
					if propRef.Value.Nullable {
						g.Id(fieldName).Op("[]*").Add(getGoType(propRef.Value.Items)).Tag(tags)
					} else {
						g.Id(fieldName).Op("[]").Add(getGoType(propRef.Value.Items)).Tag(tags)
					}
					continue
				}

				// 处理对象类型
				if propRef.Value.Type.Is("object") {
					if len(propRef.Value.Properties) > 0 {
						// 如果是 nullable，使用指针类型
						if propRef.Value.Nullable {
							g.Id(fieldName).Op("*").Add(getGoType(propRef)).Tag(tags)
						} else {
							g.Id(fieldName).Add(getGoType(propRef)).Tag(tags)
						}
						continue
					}
				}

				// 处理基本类型
				fieldType := getGoType(propRef)
				if propRef.Value != nil && propRef.Value.Nullable {
					tags["json"] += ",omitempty"
					tags["form"] += ",omitempty"
					tags["xml"] += ",omitempty"
					fieldType = jen.Op("*").Add(fieldType)
				}
				g.Id(fieldName).Add(fieldType).Tag(tags)
			}
		})

		// 在结构体之间添加空行
		f.Line()
	}

	// 确保输出目录存在
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// 保存到临时文件
	tempFile := filepath.Join(dir, "schemas_gen.tmp")
	if err := f.Save(tempFile); err != nil {
		return fmt.Errorf("failed to save temporary file: %w", err)
	}

	// 读取临时文件内容
	content, err := os.ReadFile(tempFile)
	if err != nil {
		return fmt.Errorf("failed to read temporary file: %w", err)
	}

	// 写入到目标文件
	if err := os.WriteFile(out, content, 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	// 删除临时文件
	if err := os.Remove(tempFile); err != nil {
		fmt.Printf("Warning: failed to remove temporary file: %v\n", err)
	}

	return nil
}

func getGoType(schemaRef *openapi3.SchemaRef) jen.Code {
	// 处理引用类型

	if schemaRef.Ref != "" {
		refParts := strings.Split(schemaRef.Ref, "/")
		refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
		return jen.Id(refTypeName)
	}
	schema := schemaRef.Value

	switch {
	case schema.Type.Is("string"):
		if schema.Format == "date-time" {
			return jen.Qual("time", "Time")
		}
		return jen.String()
	case schema.Type.Is("integer"):
		if schema.Format == "int64" {
			return jen.Int64()
		}
		return jen.Int()
	case schema.Type.Is("number"):
		if schema.Format == "double" {
			return jen.Float64()
		}
		return jen.Float32()
	case schema.Type.Is("boolean"):
		return jen.Bool()
	case schema.Type.Is("array"):
		if schema.Items != nil {
			if schema.Items.Ref != "" {
				refParts := strings.Split(schema.Items.Ref, "/")
				refTypeName := strcase.ToCamel(refParts[len(refParts)-1])
				return jen.Index().Id(refTypeName)
			}
			return jen.Index().Add(getGoType(schema.Items))
		}
		return jen.Index().String()
	case schema.Type.Is("object"):
		if len(schema.Properties) > 0 {
			return jen.StructFunc(func(g *jen.Group) {
				for propName, propRef := range schema.Properties {
					if propRef == nil || propRef.Value == nil {
						continue
					}
					fieldName := strcase.ToCamel(propName)
					fieldType := getGoType(propRef)
					tags := map[string]string{"json": propName}
					if propRef.Value.Nullable {
						tags["json"] += ",omitempty"
						fieldType = jen.Op("*").Add(fieldType)
					}
					g.Id(fieldName).Add(fieldType).Tag(tags)
				}
			})
		}
		return jen.Map(jen.String()).Interface()
	default:
		return jen.Interface()
	}
}
